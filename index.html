<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: manipulation; /* Prevents double-tap zoom */
            overflow: hidden; /* Prevents scrolling the page */
        }
        canvas {
            background-color: #1a202c; /* Dark background for the game */
            display: block;
            margin: 0 auto;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Responsive sizing */
            width: 100%;
            max-width: 400px; /* Max size on large screens */
            aspect-ratio: 1 / 1; /* Maintain a square shape */
        }
        .touch-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 150px;
            height: 150px;
            margin-top: 20px;
        }
        .touch-btn {
            background-color: #4a5568;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            cursor: pointer;
        }
        .touch-btn:active {
            background-color: #2d3748;
        }
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }
        .down { grid-column: 2; grid-row: 3; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-sm mx-auto text-center">
        <h1 class="text-4xl font-bold mb-4">Custom Snake</h1>
        <p class="mb-4 text-gray-400">Use Arrow Keys or Touch Controls</p>
        
        <!-- Game Canvas (width/height removed for responsiveness) -->
        <canvas id="gameCanvas"></canvas>

         <!-- Touch Controls for Mobile -->
        <div class="touch-controls md:hidden mx-auto">
            <div class="touch-btn up" id="btn-up">▲</div>
            <div class="touch-btn left" id="btn-left">◀</div>
            <div class="touch-btn right" id="btn-right">▶</div>
            <div class="touch-btn down" id="btn-down">▼</div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg text-center shadow-lg">
            <h2 class="text-3xl font-bold text-red-500 mb-4">Game Over</h2>
            <p class="text-xl mb-2">Your Score: <span id="finalScore">0</span></p>
            <p class="text-xl mb-6">High Score: <span id="highScore">0</span></p>
            <button id="restartButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                Restart
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');
        const restartButton = document.getElementById('restartButton');

        // --- Game Configuration ---
        const TILE_COUNT = 20; // The grid will always be 20x20
        let GRID_SIZE = 20; // The size of each tile in pixels, will be calculated dynamically
        
        let snakeHeadImg = new Image();
        // FIX: Reverted to the direct URL to fix the "Failed to load" error in this environment.
        // When you deploy to GitHub, you can change this back to './assets/snake-head.png'
        // after you've uploaded the image file there.
        snakeHeadImg.src = './assets/Picsart_25-08-19_21-37-57-917.png'; 
        snakeHeadImg.onerror = () => {
            console.error("Failed to load image. A default color will be used.");
            snakeHeadImg = null; // Set to null to trigger fallback drawing
        };
        
        // FIX: Reverted to the data URI for the sound to ensure it works without a local file.
        // When you deploy to GitHub, you can change this back to './assets/crash.mp3'
        // after you've uploaded the audio file there.
        let crashSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');

        // --- Game State ---
        let snake = [{ x: 10, y: 10 }];
        let food = { x: 15, y: 15 };
        let velocity = { x: 0, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('snakeCustomHighScore') || 0;
        let gameOver = false;
        let gameStarted = false;
        let changingDirection = false;

        // --- Canvas Sizing ---
        function resizeCanvas() {
            // Use the displayed width of the canvas (set by CSS)
            const size = canvas.clientWidth;
            // Set the internal resolution to match, ensuring a crisp grid
            canvas.width = size;
            canvas.height = size;
            // Recalculate grid size based on new canvas size
            GRID_SIZE = canvas.width / TILE_COUNT;
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if (gameOver) return;
            changingDirection = false;
            update();
            draw();
        }

        function update() {
            if (!gameStarted) return;

            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };
            snake.unshift(head);

            // Wall collision
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                triggerGameOver();
                return;
            }

            // Self collision
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    triggerGameOver();
                    return;
                }
            }

            // Food collision
            if (head.x === food.x && head.y === food.y) {
                score++;
                generateFood();
            } else {
                snake.pop();
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw snake
            snake.forEach((segment, index) => {
                if (index === 0) { // Head
                    if (snakeHeadImg && snakeHeadImg.complete) {
                        ctx.drawImage(snakeHeadImg, segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    } else { // Fallback if image fails
                        ctx.fillStyle = '#48BB78'; // Green
                        ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                    }
                } else { // Body
                    ctx.fillStyle = '#38A169'; // Darker Green
                    ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                }
            });

            // Draw food
            ctx.fillStyle = '#E53E3E'; // Red
            ctx.fillRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
            
            // Draw Score
            ctx.fillStyle = '#fff';
            ctx.font = `${GRID_SIZE * 0.8}px "Press Start 2P"`;
            ctx.fillText(`Score: ${score}`, 10, GRID_SIZE);
            
            if (!gameStarted && !gameOver) {
                ctx.font = `${GRID_SIZE * 0.7}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.fillText("Press Arrow Key", canvas.width / 2, canvas.height / 2 - GRID_SIZE);
                ctx.fillText("To Start", canvas.width / 2, canvas.height / 2 + GRID_SIZE);
                ctx.textAlign = 'left';
            }
        }

        // --- Helper Functions ---
        function generateFood() {
            food.x = Math.floor(Math.random() * TILE_COUNT);
            food.y = Math.floor(Math.random() * TILE_COUNT);
            for (const segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    generateFood(); // Recursively find a new spot
                    return;
                }
            }
        }

        function resetGame() {
            resizeCanvas(); // Ensure canvas is correctly sized before drawing
            snake = [{ x: 10, y: 10 }];
            velocity = { x: 0, y: 0 };
            score = 0;
            gameOver = false;
            gameStarted = false;
            generateFood();
            gameOverModal.classList.add('hidden');
            draw();
        }

        function triggerGameOver() {
            if (gameOver) return;
            crashSound.play();
            gameOver = true;
            gameStarted = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeCustomHighScore', highScore);
            }
            finalScoreEl.textContent = score;
            highScoreEl.textContent = highScore;
            gameOverModal.classList.remove('hidden');
        }

        // --- Event Listeners ---
        function handleDirectionChange(e) {
             if (changingDirection) return;
             
            const keyPressed = e.key;
            const goingUp = velocity.y === -1;
            const goingDown = velocity.y === 1;
            const goingRight = velocity.x === 1;
            const goingLeft = velocity.x === -1;

            if (!gameStarted) gameStarted = true;

            // Prevent the snake from reversing on itself
            if (keyPressed === "ArrowLeft" && !goingRight) {
                velocity = { x: -1, y: 0 };
            } else if (keyPressed === "ArrowUp" && !goingDown) {
                velocity = { x: 0, y: -1 };
            } else if (keyPressed === "ArrowRight" && !goingLeft) {
                velocity = { x: 1, y: 0 };
            } else if (keyPressed === "ArrowDown" && !goingUp) {
                velocity = { x: 0, y: 1 };
            }
            changingDirection = true;
        }
        
        document.addEventListener('keydown', handleDirectionChange);
        restartButton.addEventListener('click', resetGame);
        window.addEventListener('resize', resetGame); // Reset game on resize to adjust grid

        // --- Touch controls setup ---
        function setupTouchControls() {
            const buttons = {
                'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown',
                'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight'
            };
            for (const [id, key] of Object.entries(buttons)) {
                const buttonEl = document.getElementById(id);
                if (buttonEl) {
                    buttonEl.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevents click delay and page scrolling
                        handleDirectionChange({ key: key });
                    }, { passive: false });
                }
            }
        }

        // --- Initial Setup ---
        window.onload = () => {
            setupTouchControls();
            resetGame();
            setInterval(gameLoop, 1000 / 10); // Game speed: 10 frames per second
        };
    </script>
</body>
</html>


